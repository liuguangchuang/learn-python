# -*- coding: utf-8 -*-
# Time: 2019/5/24 23:26
# Author: laugc
# Email: hahalgc@gmail.com
# File: py54_reg.py

"""
正则表达式
"""

import re

"""
用 \d 可以匹配一个数字，\w 可以匹配一个字母或数字
00\d 可以匹配 007，但无法匹配 00A
\d\d\d 可以匹配 010
\w\w\d 可以匹配 py3
. 可以匹配任意字符
* 表示任意个字符，包括 0 个
+ 表示至少一个字符
? 表示 0 个或 1 个字符
{n} 表示 n 个字符
{n,m} 表示 n-m 个字符
"""

"""
例如：\d{3}\s+\d{3,8}
\d{3} 表示匹配3个数字，例如 010
\s 可以匹配一个空格，也包括 Tab 等空白符，所以 \s+ 表示至少有一个空格，例如匹配' '，' '等
\d{3,8} 表示 3-8 个数字，例如 1234567
"""

"""
要做更精确地匹配，可以用 [] 表示范围
[0-9a-zA-Z\_] 可以匹配一个数字、字母或者下划线
[0-9a-zA-Z\_]+ 可以匹配至少由一个数字、字母或者下划线组成的字符串，比如 a100，0_Z，Py3000 等等
[a-zA-Z\_][0-9a-zA-Z\_]* 可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串
[a-zA-Z\_][0-9a-zA-Z\_]{0, 19} 更精确地限制了变量的长度是 1-20 个字符，前面 1 个字符 + 后面最多 19 个字符

A|B 可以匹配 A 或 B，所以 (P|p)ython 可以匹配 Python 或者 python
^ 表示行的开头，^\d 表示必须以数字开头
$ 表示行的结束，\d$ 表示必须以数字结束
py 也可以匹配 python，但是加上 ^py$ 就变成了整行匹配，就只能匹配 py 了
"""

# r 前缀，就不用考虑转义，s 和 s1 一样
s = 'ABC\\-001'
s1 = r'ABC\-001'

# match() 方法判断是否匹配，如果匹配成功，返回一个 Match 对象，否则返回 None
print(re.match(r'\d{3}\-\d{3,8}$', '010-12345'))
print(re.match(r'\d{3}\-\d{3,8}$', '010 12345'))

# 切分字符串
print(re.split(r'\s+', 'a b   c'))
print(re.split(r'[\s\,]+', 'a,b, c  d'))
print(re.split(r'[\s\,\;]+', 'a,b;; c  d'))

# 分组
# 用 () 表示的就是要提取的分组，^(\d{3})-(\d{3,8})$ 分别定义了两个组
m = re.match(r'^(\d{3})-(\d{3,8})$', '010-12345')
# group(0) 是原始字符串
print(m.group(0))
print(m.group(1))
print(m.group(2))
print("=================")

t = '19:05:30'
m1 = re.match(r'^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2['
              r'0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$', t)
print(m1.groups())

# 贪婪匹配
# 正则匹配默认是贪婪匹配
# 匹配出数字后面的 0
# 由于 \d+ 采用贪婪匹配，直接把后面的 0 全部匹配了，结果 0* 只能匹配空字符串
print(re.match(r'^(\d+)(0*)$', '102300').groups())
# 加个 ? 就可以让 \d+ 采用非贪婪匹配
print(re.match(r'^(\d+?)(0*)$', '102300').groups())
print("====================")

# 编译
re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')
print(re_telephone.match('010-12345').groups())
print(re_telephone.match('010-8086').groups())
